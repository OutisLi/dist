(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{311:function(t,s,a){"use strict";a.r(s);var n=a(14),v=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"_2023-11-16-阻塞与非阻塞赋值"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2023-11-16-阻塞与非阻塞赋值"}},[t._v("#")]),t._v(" 2023.11.16-阻塞与非阻塞赋值")]),t._v(" "),s("p",[s("img",{attrs:{src:"2023%2011%2016-%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%B5%8B%E5%80%BC%20fe2d8f44589b419a988fd54b508bb423/Untitled.png",alt:"Untitled"}})]),t._v(" "),s("p",[s("img",{attrs:{src:"2023%2011%2016-%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%B5%8B%E5%80%BC%20fe2d8f44589b419a988fd54b508bb423/Untitled%201.png",alt:"Untitled"}})]),t._v(" "),s("p",[t._v("组合逻辑电路使用阻塞赋值")]),t._v(" "),s("p",[t._v("时序逻辑电路使用非阻塞赋值")]),t._v(" "),s("p",[t._v("在 Verilog 中，阻塞赋值（Blocking Assignment）和非阻塞赋值（Non-Blocking Assignment）是两种不同的信号赋值方法，它们在时序逻辑的模拟和硬件描述语言（HDL）代码的编写中有着重要的区别。")]),t._v(" "),s("h3",{attrs:{id:"阻塞赋值-blocking-assignment"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#阻塞赋值-blocking-assignment"}},[t._v("#")]),t._v(" "),s("strong",[t._v("阻塞赋值（Blocking Assignment）")])]),t._v(" "),s("ul",[s("li",[t._v("使用符号 "),s("strong",[s("code",[t._v("=")])]),t._v(" 进行赋值。")]),t._v(" "),s("li",[t._v("阻塞赋值在执行时会“阻塞”代码的进一步执行，直到赋值完成。")]),t._v(" "),s("li",[t._v("在执行下一条语句之前，当前语句必须完成其操作。")]),t._v(" "),s("li",[t._v("在组合逻辑设计中常用，但在时序逻辑中使用可能会导致问题，因为它们可能会引起模拟时序和硬件时序的不一致。")])]),t._v(" "),s("p",[s("strong",[t._v("举例")]),t._v("：")]),t._v(" "),s("div",{staticClass:"language-verilog extra-class"},[s("pre",{pre:!0,attrs:{class:"language-verilog"}},[s("code",[t._v("a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nc "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("在这个例子中，"),s("strong",[s("code",[t._v("c = a;")])]),t._v(" 会等待 "),s("strong",[s("code",[t._v("a = b;")])]),t._v(" 完成后才执行。")]),t._v(" "),s("h3",{attrs:{id:"非阻塞赋值-non-blocking-assignment"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#非阻塞赋值-non-blocking-assignment"}},[t._v("#")]),t._v(" "),s("strong",[t._v("非阻塞赋值（Non-Blocking Assignment）")])]),t._v(" "),s("ul",[s("li",[t._v("使用符号 "),s("strong",[s("code",[t._v("<=")])]),t._v(" 进行赋值。")]),t._v(" "),s("li",[t._v("非阻塞赋值允许代码的后续部分在赋值完成之前继续执行。")]),t._v(" "),s("li",[t._v("这意味着所有非阻塞赋值都是并行发生的（或看起来如此），这更接近于硬件的实际行为。")]),t._v(" "),s("li",[t._v("在时序逻辑，特别是在描述触发器（如寄存器）的行为时非常重要和常用。")])]),t._v(" "),s("p",[s("strong",[t._v("举例")]),t._v("：")]),t._v(" "),s("div",{staticClass:"language-verilog extra-class"},[s("pre",{pre:!0,attrs:{class:"language-verilog"}},[s("code",[t._v("a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nc "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=")]),t._v(" a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("在这个例子中，"),s("strong",[s("code",[t._v("c <= a;")])]),t._v(" 不会等待 "),s("strong",[s("code",[t._v("a <= b;")])]),t._v(" 的完成。"),s("strong",[s("code",[t._v("a")])]),t._v(" 和 "),s("strong",[s("code",[t._v("c")])]),t._v(" 的赋值看似同时发生。")]),t._v(" "),s("p",[t._v("在一个always块中，不同地方对同一个变量的赋值会被同时执行，最终结果是变量变成最后一次赋值的结果（前面的操作被覆盖）")])])}),[],!1,null,null,null);s.default=v.exports}}]);